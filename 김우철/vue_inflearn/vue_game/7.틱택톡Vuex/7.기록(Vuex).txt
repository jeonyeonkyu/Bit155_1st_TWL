store.js 만들기
vue에서는 store 여러개 만들기 가능

리액트의 리덕스에서는 store 딱 하나만 만들어야됨

대만인이 vue만듬

한국/영미권은 리액트
중화권은 vue가 인기가 많음

npm i vuex 다운

vuex의 4가지 핵심
    state: {

    },
    mutations: {

    },
    getters: {
        
    },
    actions: {

    },

vue는 원리보단 아 그냥 이렇게 동작하는구나 라고 받아들이는게 정신상 좋음

     this.$store.commit('CLICK_CELL');
     뮤테이션을 부를때는 commit으로 부름

    
export const와 export default의 차이
export default를 하면 import로 바로 가져올 수 있고 이름을 마음대로 지어줄 수 있음
- 가장 중요한 것만 딱 하나 함

export는 const는 이름 그대로 {}로 묶어서 이름 그대로 적어줘야함


Vue랑 Vuex를 연결하고 : Vue.use(Vuex); 
 Vuex랑 root랑 연결해줘야함 : 
 import store from './store';

    export default {
        store,
>>여긴 Tictactoe에서..


Vuex를 쓰면 Vue 데브툴의 두번쨰 탭에서 데이터 확인 가능
-> 데이터를 어떻게 바꿨는지 추적 가능(기록으로 남음) >> 씹 장점

화면에 데이터가 안보여지는 문제는 거의 배열 문제
>>여기서는 Vuex에서 td로 바로 쏴주면됨


store에 있는 state들을 컴포넌트에서 쓰기위해서 computed에 일일히 다 적어주는건(연결) 귀찮
>> mapState 사용하면 해결

        computed: {
            ...mapState(['winner', 'turn']), //이것만 알면 나머지는 응용
            // ...mapState({
            //     winner: state => state.winner,
            //     turnState: 'turn',
            // }) //이런식으로 이름을 바꿀 수도 있음(버전1) / 화살표 함수는 this 사용 못함
            // ...mapState({
            //     winner(state){
            //         return state.winner + this.data; //component에 있는 데이터를 짬봉 가능
            //     },
            //     turnState: 'turn',
            // }) //버전 2
            // winner(){
            //     return this.$store.state.winner;
            // },
            // turn() {
            //     return this.$store.state.turn;
            // } 
        },

vue 데브툴 분석

vuex에서 배열을 computed  매번실행됨 
>> 한칸만 클릭해도 전체를 렌더링함
>> 이부분은 어쩔수 없음
>> 걍 tictactoe에서 하나로 합치는게 낳을듯
(table, td, tr 다 필요없음)

slot(어렵다)
다른 컴포넌트에 태그를 넘겨주는 방법
똑같이 리액트에는 children와 같은 개념이 있음

자식컴포넌트에 적었어야될 데이터나 메소드를 자식컴포넌트에 적지않아도 
부모컴포넌트의 데이터나 메소드 등에 접근 가능
(자식 컴포넌트를 부모컴포넌트가 제어)
IoC / DI 개념

유용한 이유
나중에 가면 남의코드를 많이 쓸텐데(라이브러리) IoC를 허용한 라이브러리가 있고 허용하지않는 라이브러리가 있음
>>IoC를 허용한 라이브러리가 커스터마이징하기 더 편함

틱택톡 -> 테이블 -> 자식X
틱택톡 -> 테이블 - >다시 틱택톡..

   <tr v-for="(rowData, rowIndex) in tableData" :key="rowIndex">
key를 인덱스로 쓰는 경우 좋을떄가 있고 안좋을떄가 있다
좋을때
1.배열의 값이 계속 증가하거나 중간의 값이 수정되는 경우라도 인덱스값은 변하지 않으므로 ㄱㅊ
>>새로운 값만 렌더링함
안좋을때
>>하지만 중간값이 지워질때 지워진 이후의 값을 다시 다 렌더링(단점)




