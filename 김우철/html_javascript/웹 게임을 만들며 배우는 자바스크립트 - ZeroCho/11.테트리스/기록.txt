function 칸만들기() { //10X20 칸
    var fragment = document.createDocumentFragment();
    for(var i = 0; i < 20; i++) {
        var tr = document.createElement('tr');
        fragment.appendChild(tr);
        for(var j = 0; j < 10; j++) {
            var td = document.createElement('td');
            tr.appendChild(td);
        }
    }
    tetris.appendChild(fragment);
}

-> 화면에 직접 추가하는 방식이 아님
-> 프레그먼트(메모리)에 appendChild 한뒤
나중에 프레그먼트를 tetris에 한방에 붙힘

화면에서 조작하는 것 보단 메모리에서 조작하는 것은 빨라서
메모리에서 먼저 조작을 해서 화면에 붙힘


window.addEventListener('keyup', function(e) {

keypress는 방향키 인식이 안됨

도형을 데이터로 표현하는 것이 중요

css는 id말고 class로 만드는 것이 js에서 접근할 때 편함

setInterval(tick, 2000)
-> setInterval만 호출한거라 setInterval만 호출스택에 들어가고
tick은 들어가지 않음(tick은 태스트 큐에 들어감)
이벤트 루프는 호출스택이 비어져 있지만 태스트큐에서 함수(tick)를 꺼내서 
호출스택에 올림

호출스택에 setInterval 올라감
-> 백그라운드에 tick, 2초마다가 들어감 -> setInterval 없어짐
 -> tick가 2초마다 태스크 큐에 들어감 -> 
 이벤트루프가 호출스택에 tick를 올림 -> 재실행(setInterval만 실행) -> 반복..


예제) : 이게 JS의 가장 중요한 핵심중의 핵심
function a() {
    setInterval(b, 2000)
}

function b() {
    setTimeout(c, 3000)
}

function c() {
    hello();
}

a();

최신 문법
var 변수이름 = 값
//함수 스코프
//var 거의 안씀
최신문법
const 변수이름 = 값 : 고정값
let 변수이름 = 값 : 변하는 값
둘다 블록스코프(중괄호가 블록)
블록스코프가 훨씬 편함

예제)
if(true){
    const a = 1;
}
console.log(a); /not defined error

함수선언 구문법

function 함수명() {
    
}
//var은 사라졌지만 이건 안사라짐

최신문법
const 함수명 = () => {

}

차이점은 this가 다르다
자세한 점은 제로초 블로그 참조

화살표함수가 편한점
const 함수명2 = 인자 => {
    return 리턴값;
}
return 밖에 없을 시 
아래처럼 생략가능
const 함수명2 = 인자 => 리턴값

JSON.stringify() : JS나 객체를 JSON 문자열로 반환
JSON.parse() : JSON을 JS나 객체로 변환

//최신문법(엄청 유용)
[...Array(20).keys()].forEach((col, i) => { //??
...은 스프레드라는 최신 문법

ex)
...[1,2,3] -> 1,2,3
func(...[1,2,3])
func(1,2,3)

[...Array(숫자).keys()]
[0,1,2,3,....,숫자-1]
>>0부터 숫자-1까지
>> 숫자-1까지 배열 생성


[...Array(숫자).keys().map((v) => v+1))]
[1,2,3,.....,숫자]
>> 1부터 숫자까지




