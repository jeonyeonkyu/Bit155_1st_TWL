
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Insert title here</title>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	<script type="text/javascript">
	/*  
	https://www.zerocho.com/category/jQuery
	제이쿼리 프로미스(promise)와 Deferred
	제이쿼리 프로미스 패턴
	
	
	제이쿼리 프로미스의 기본 구조는 프로미스 객체가 완료되었을 때 done 메소드가 호출되고 
	실패했을 때는 fail, 
	완료되었건 실패했건 행동이 끝났으면 always가 호출
	
	1.
	var longAndComplicatedFunction = function() {
		  try {
		    // 완료되려면 50초가 걸리는 매우 복잡한 코드
		    console.log('성공');
		  } catch (err) {
		    console.log('실패');
		  }
		};
		longAndComplicatedFunction();
		console.log('다음 행동');
		
		이렇게 복잡한 코드가 있으면 이 코드를 실행하는 50초 동안은 아무 것도 할 수 없습니다. 
		50초 후에야 다음 행동이 실행될 겁니다.
		
	*/
	
	
	var longAndComplicatedFunction = function() {
		  var deferred = $.Deferred();
		  try {
		    // 완료되려면 50초가 걸리는 매우 복잡한 비동기 코드
		    deferred.resolve('성공');
		  } catch (err) {
		    deferred.reject(err);
		  }
		  return deferred.promise();
		};
		
		
		longAndComplicatedFunction().done(function(message) {
		  console.log("message : " + message);
		}).fail(function(error) {
		  console.log(error);
		}).always(function() {
		  console.log('완료!');
		});
		console.log('다음 행동');
		
	</script>
	<!-- 
	이렇게 $.Deferred()로 deferred 객체를 만들고,
	 성공했을 때에는 resolve, 
	 실패했을 때에는 reject 메소드를 호출하면 
	 resolve는 done으로, 
	 reject는 fail로 연결됩니다.
	 
	 
	 이제 비동기 방식으로 했기 때문에 다음 행동은 50초를 기다릴 필요 없이 바로 실행되고, 
	 복잡한 행동이 완료되었을 시 등록해둔 done 메소드가 실행됩니다. 
	 실패했다면 fail 메소드가 실행되고요. 
	 longAndComplicatedFunction 함수에서 deferred.promise()를 return하는 것을 잊지 마세요!
	
	
	done이나 fail로 구분하지 않고 한 번에 처리하려면 then 메소드가 있습니다. 
	첫 번째 인자는 성공 시 콜백이고, 
	두 번째 인자는 실패 시 콜백입니다. 
	then도 연달아 쓸 수 있습니다.
	longAndComplicatedFunction().then(function(message) {
	  console.log(message);
	}, function(error) {
	  console.log(error);
	}).then(function() {
	  console.log('완료!');
	});
	
	
	$.when은 여러 개의 비동기 프로미스 함수를 동시에 처리할 수 있게 해줍니다.
	$.when(longAndComplicatedFunction(), longerAndMoreComplicatedFunction()).done(function(result1, result2) {
  	   console.log(result1, result2);
	});
	
	$.when 안에 여러 개의 프로미스 함수를 넣어줍니다. 
	함수들이 모두 종료되었을 때 연결해둔 done 메소드의 콜백이 실행됩니다. 
	longAndComplicatedFunction의 결과는 result1으로, 
	longerAndMoreComplicatedFunction의 결과는 result2로 연결됩니다.
        여러 개의 프로미스를 동시에 처리할 수 있기 때문에 편리합니다. 
        특히 선행 조건으로 비동기 함수 여러개가 필요한 경우 
    $.when을 쓰면 효과적으로 코딩을 할 수 있습니다. 
    done 메소드에서 비동기 함수의 결과들을 한 번에 받을 수 있으니까요.
	 -->
</head>
<body>

</body>
</html>