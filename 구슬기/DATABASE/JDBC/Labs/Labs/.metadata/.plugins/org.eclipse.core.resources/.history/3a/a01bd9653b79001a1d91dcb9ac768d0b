import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;
import java.util.Scanner;

/*
 DML(insert , update, delete)
 JDBC API 통해서
 1. 결과 집합이 없다. 반대되는 개념은 select (결과 집합 있음) 
 2. 반영된 결과 row를 return 해준다.  
         java 코드
         ex) update emp set sal=0 >> 14건 변경 된다.  >> return 14 이렇게 준다.      return 값이 0보다 크면 성공한거 이렇게 판단한다.
             update emp set sal=0 where empno=11111 >> return 0   저런 사원이 없어서 반영된게 없으니까 return 은 0, 에러는 아님.  
             
         java 코드 : 성공..... 실패 로직 여러분 마음이다. 
  
  KEY POINT   **정말 중요한 얘기**
  1. Oracle 에서 DML 작업( Tool, cmd )하면 반드시 commit or rollback 강제 했었는데
  2. JDBC API 에서는 자바 코드를 통해서 DML 을 하면    >>  default AutoCommit ....자동 실반영된다.
  3. java code 에서  delete from emp 하면 실행 하고 자동 Commit >>  실반영
  4. 필요에 따라서 commit() , rollback()   들을  java 코드에서 제어가능 하게 만듦       
  
      
      시작
      A 계좌 이출 (update)
      
      ..
      
      B 계좌 입금 (update)
      
     
      끝 
  >>하나의 논리적인 단위(transaction)
  >>autocommit 옵션을 >> false로 바꿈     
  >>그럼 java code 에서 명시적으로 commit, rollback 할수 있다.
  
  
 */
public class Ex02_Oracle_DML {

	public static void main(String[] args) {
		Connection conn = null;
		Statement stmt = null;
		
		
		try {
			//Class.forName("oracle.jdbc.OracleDriver");
			 conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:XE","bit","1004");
			 stmt = conn.createStatement();
			 
			 //INSERT
			 int empno =0;
			 String ename ="";
			 int deptno =0;
			 
			 Scanner sc = new Scanner(System.in);
			 System.out.println("사번입력: ");
			 empno = Integer.parseInt(sc.nextLine());
			 
			 System.out.println("이름입력: ");
			 ename = sc.nextLine();
			 
			 System.out.println("부서번호입력: ");
			 deptno = Integer.parseInt(sc.nextLine());
			 
			 //insert into dmlemp(empno,ename,deptno) values(100,'홍길동',10);
			 
		}catch(Exception e){
			
		}finally {
			
		}
		

	}

}
