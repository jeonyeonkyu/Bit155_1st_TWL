클래스 여러개 추가할때
=> card.classList.add('card')
하나만 추가할 때
=> card.className = 'card';

 card.addEventListener("click", function() {
      card.classList.toggle("flipped");
    });
=> flipped라는 클래스가 있으면 넣고 없으면 뺴는 형식
=> toggle 잘알아두기


  card.addEventListener("click", function() {
      card.classList.toggle("flipped");
    });
    이대로 쓰면 클로저 문제 발생

     (function(c) {
      card.addEventListener("click", function() {
        c.classList.toggle("flipped");
      });
    })(card);
    => 클로저 문제 해결

무작위 섞기와 같이 자주쓰는 코드는 따로 지정해둘것

document.querySelectorAll(".card").forEach(function(card, index) {
    setTimeout(function() {
      card.classList.add("flipped");
    }, 1000 + 100 * index);
  });
=> forEach에서는 index를 지정해줄 수 있다.


  setTimeout(function() {
      클릭카드[0].classList.remove('flipped');
      클릭카드[1].classList.remove('flipped');
      클릭플래그 = true;
    }, 1000);
      클릭카드 = [];
=> 이경우 비동기 함수인 setTimeout보다 클릭카드 = []; 이것이 먼저 실행되기 때문에
클릭카드 = []이것을 setTimeout() 안에 넣어줘야한다.


배열도 객체

참조관계를 끊는 방법(slice() 이용)
var 색깔들 = [
  "red",
  ....
];
var 색깔후보 = 색깔들.slice(); 
=> 색깔들과 색깔후보의 참조관계가 끊김

.slice()
=>배열의 일부분을 선택하여 새로운 배열을 만듬

참조와 복사

경우1
var 값 = '제로초'
var 복사 = 값;
복사 = '무지'
=>값은 그대로 제로초가 나옴
=> 값만 복사한것
=>숫자,문자,boolean, undefined, null은 값을 넣어줘도 따로 작용한다.


그냥 객체,배열,함수 일때는 말이 다르다

var 사람 = {
  이름: '제로초'
}
var 복제인간 = 사람;
복제인간.이름 = '무지';
=> 사람.이름도 무지로 바뀜
=> 객체는 대입하면 참조관계(연결)가 된다

만약 값만 그대로 복사하고 싶으면?
var obj = {a:1, b:2}
var obj2 = {}
방법1(하나씩 넣는다 무식)
obj2.a = obj.a;
obj2.b = obj.b;

방법2(잘 알아두기)
Object.keys(obj).forEach(function(key){
  obj2[key] = obj[key];
})
=> Object.keys() 메서드는 객체의 속성명들을 배열로 바꿈
=> 단점 : 
var obj = {a: 1, b: { c: 1} } 일시 key를 이용해 복사를 하면
a는 값만 복사되지만
b.c는 참조관계를 벗어나지 못한다.
=>
foreach를 풀어보면
obj2.a = obj.a;
obj2.b = obj.b
이런식으로 되는데 b는 값이 아닌 객체자체이기 때문에 참조가 된것
=> 불안정함
=>리액트나 리덕스같은경우 객체안의객체안의객체..가
수없이 많을 수 있기 때문에 이부분은 잘알아둬야함. 
=>해결법(재귀이용)
function copyObj(obj) {
  var copy = {};
  if (Array.isArray(obj)) {
    copy = obj.slice().map((v) => {
      return copyObj(v);
    });
  } else if (typeof obj === 'object' && obj !== null) {
    for (var attr in obj) {
      if (obj.hasOwnProperty(attr)) {
        copy[attr] = copyObj(obj[attr]);
      }
    }
  } else {
    copy = obj;
  }
  return copy;
}
obj2 = copyObj(obj)
=>하지만 이 방법도 불안정함

참조관계인지 아닌지 파악하는 방법
obj === obj2
=> true가 나오면 참조관계

방법4
obj = {a:1, b:{c:1}}
obj2 = JSON.parse(JSON.stringify(obj))
=> 1단계든 2단계는 복사 해줌
=> 성능이최악이라 최대한 안쓰는게 좋음
=> 애도 완벽한 복사는 아님..
=>
JSON.parse() :  string 객체를 json 객체로 변환
JSON.stringify : json 객체를 String 객체로 변환


방법3
=> slice() 이용
단점 
=> 정확히는 깊은복사가 아님
=> 1단계만 복사하기 때문에 위의 예시와 같이 b,c는 복사를 못함


소통할때는 용어가 중요하다
얕은복사 = 참조 / 깊은 복사 = 복사


제로초 깊은복사, 얕은복사 참조
https://www.zerocho.com/category/JavaScript/post/5750d384b73ae5152792188d


팩토리패턴과 프로토타입

var card = {
  name: '제로초',
  att: 5,
  hp: 10,
  type: '카드',
  attack: function() {
    console.log('공격!!!');
  },
  defend : function() {
    console.log('방어!!!');
  },
};

var card2 = {
  name: '무지',
  att: 1,
  hp: 3,
  type: '카드',
  attack: function() {
    console.log('공격!!!');
  },
  defend : function() {
    console.log('방어!!!');
  },
};

=>
  type: '카드',
  attack: function() {
    console.log('공격!!!');
  },
  defend : function() {
    console.log('방어!!!');
  },
  이부분이 중복됨, 이를 해결해줘야함

해결법1(팩토리 패턴 이용)
function 카드공장(name, att, hp){
  return{
    name: name,
    att: att,
    hp: hp,
    type: '카드',
    attack: function() {},
    defend: function() {},
  };
}
var card =  카드공장('제로초', 10, 10);
var card2 =  카드공장('무지', 1, 2);


해결법2(프로토 타입 이용)
var prototype = { //공통된 부분만 만듬
  type: '카드',
  attack: function() {},
  defend:" function() {},
}

var card = {
  name: '제로초',
  att: 10,
  hp: 10,
}

card.__proto__ = prototype;

card 객체 안
 att:10
 hp: 10
 name: "제로초"
__proto__:
  attack: f()
  defend: f()
  type: "카드"
  __proto__: //여기가 마지막 proto
    ....
    ....

__proto__는 객체안에 항상 숨어져 있음

객체의 속성에 접근하는 방법(__proto__ 생략가능 : js가 객체의 속성을 찾을때 알아서 붙임)
card.type
=> "카드"
card.toString()
=> "[object Object]"


실무에서 팩토리 패턴을 무지하게 많이씀
-> 생성자를 안쓰기 위해 사용하는 방법이 팩토리 패턴임

두개 합친 최종 방법
var 프로토타입 = {
  type: '카드',
  attack: function() {},
  defend: function() {},
};
function 카드공장(name, att, hp){ //달라지는 부분은 매개변수에 입력
  var 카드 = {
    name: name,
    att: att,
    hp: hp,
  }
  카드.__proto__ = 프로토타입 //공통 부분
  return 카드;
}
=> 실무에서는 이런 방법으로 잘안함

var 프로토타입으로 해서 밖으로 빼서 쓰는 이유는
카드공장으로 수백개찍힌 카드의 type을 한번에 바꾸기 위해서다


실무에서는 __proto__를 사용하면 안된다.(비표준이라서)
Object.create()

Js공식 적인사이트 2위 = mdn
1위는 https://www.ecma-international.org/ecma-262/#sec-info8
-> 극찬 / 그러나 너무 많음
그래서 mdn에서 이를 정리해논 것
-> mdn에서 warning이나 따봉밑으로 되어있는것은 쓰지않는게 좋음

var 프로토타입 = {
  type: '카드',
  attack: function() {},
  defend: function() {},
};
Object.create(프로토타입) //이걸 쓰면 프로토타입을 적용해줌

var 카드 = Object.creaet(프로토타입)
이거로
var 카드 = {};
카드.__proto__ = 프로토타입
이것을 대체


Object.assign으로 1단계 복사 가능
Object.assign(obj2, obj1);
-> obj2에 obj1을 넣음


프로토타입 = 객체들간의 공유자료
-> 한방에 crud를 할 수 있기 때문에 사용



