크롬에서 숫자는 파란색으로 나옴

2차원 배열 만들 시 세로먼저 만들고 가로 만들기

 table {
        border-collapse: collapse;
      }
      -> 경계석간의 간격들이 합쳐짐


//배열 초기화, 이부분 잘 알아두기
  var 후보군 = Array(hor * ver)
    .fill()
    .map(function(요소, 인덱스) {
      return 인덱스 + 1;
    });

피셔예이츠 셔플로 지뢰심을 20개 위치 뽑기

  while (후보군.length > 80) {
    var 이동값 = 후보군.splice(Math.floor(Math.random() * 후보군.length), 1)[0];
    셔플.push(이동값);
  } : 20개만 뽑기

  갑자기 에러를 막고자 if문을 추가한다든지 등은 
  안적는게 좋다.

윈도우 지뢰찾기 규칙 - 첫번째 클릭은 지뢰가 아니다
-> 어떻게 구현했을까 생각해보기

깃발 : 유저가 백퍼센트 지뢰가 있다라는 표시(마우스 오른쪽 1번)
물음표 : 지뢰가 있는지 확신이 없음(마우스 오른쪽 2번):지금은 사라짐

마우스 오른쪽 클릭 이벤트 : contextmenu 이벤트

같은 이름의 변수라도 함수안에 있는것과 함수밖에 있는 변수는 다르다.
(=스코프 개념)

존재하지 않는 태그에 이벤트를 달 수 없다

e.currentTarget : 이걸 쓰는게 안헷갈림
e.target
차이점
e.currentTarget : 이벤트리스너가 달린애
e.target : 실제이벤트가 발생한애


 td.addEventListener("contextmenu", function(e) {
        e.preventDefault();
        var 부모tr = e.currentTarget.parentNode;
        var 부모tbody = e.currentTarget.parentNode.parentNode;
        var 칸 = Array.prototype.indexOf.call(부모tr.children, e.currentTarget); //클로저 문제로 읺래 td 대신 currentTarget를 넣음
        var 줄 = Array.prototype.indexOf.call(부모tbody.children, 부모tr);
      });
indexOf를 못쓰는 대상(배열이 아닌 대상들)에게 강제로 적용하는 방법
하지만 권장되지 않는 방식 : 클로저쓰는게 낳다

JS 필수 개념 : 스코프 ,실행 context ,프로토타입, 비동기, 클로저
-> 피해갈수 없음


데이터와 화면을 일치시키기 위해 리액트같은 뷰 프레임워크 사용
(jquery로 하면 매우 힘듬)

  tbody.innerHTML = "";
  -> tbody의 내부태그들을 지움


concat은 배열과 배열을 합쳐서 새로운 배열을 만들어냄



1.스코프
함수안에 선언된 변수(var)는 외부에서 접근할 수 없다.
★즉, 변수는 자신을 감싸고 있는 함수 바깥으로 빠져나갈 수 없다!


var x = "global";

function ex() {
  var x = "local"; -> 펑션(함수) 스코프
  x = "change"; ->함수안의 x는 local->change로 바뀜
}
ex(); //x를 바꿔본다
alert(x); //여전히 'global'

=> 하지만 함수안의 var을 빼면 x는 local이 됬다가 change로 바뀐다
즉 변수 선언이 제일 중요


2.스코프 체인(=스코프간의 상하관계)
var name = "zero";

function outer() {
  console.log("외부", name); ->★함수내부에 없으니 함수바깥에서 찾음, zero가 됨
  function inner() {
    var enemy = "nero";
    console.log("내부", name); -> ★inner찾아보고 없으면 outer, outer도 없으면 완전 외부로 나가서 찾음, zero가 됨
  }
  inner(); -> ★함수 inner나 변수 inner를 찾는다. 없으면 전역에서 찾는다.
}

outer();
console.log(enemy); -> undefined가 뜸

var말고 function 선언도 스코프 적용을 받는다.

최신 js에서는 var 대신 const를 사용함


3.렉시컬(static, 정적) 스코핑(의미 : 코드가 적힌 순간 스코프가 정해짐)

var name = "zero";
function log() {
  console.log(name); => 
}

function wrapper() {
  name = "nero"; ->전역변수인 name을 바꿈
  log();
}
wrapper();

--------------------

var name = "zero";
function log() {
  console.log(name); => ★zero가 나옴, 함수안에서 찾기 -> 전역에서 찾기 ->
  function wrapper에서 뭔일이 일어나든 name은 무조건 zero(126줄의 전역변수 name과 연결되있음)
}

function wrapper() {
  var name = "nero";
  log(); -> ★wrapper안에서 함수 log나 변수 log를 찾음, 없으면 바깥에서 찾음
}
wrapper();

var말고 function 선언도 스코프 적용을 받는다.


js가 다이다닉하단 소리를 듣지만 스코프만은 정적


만약 동적스코핑(함수의 실행순서에 따라 스코프가 바뀜)이면 가장최근에 실행했던 코드를 따름
var name = "zero";
function log() {
  console.log(name); -> wrapper에 있는 변수name이 최근에 실행됬으므로 nero가 찍힘
}

function wrapper() {
  var name = "nero";
  log(); 
}
wrapper();


var name = "zero";
function log() {
  console.log(name); -> wrapper에 있는 변수name이 최근에 실행됬으므로 nero가 찍힘
}

function wrapper() {
  var enemy = "비밀번호(제로초바보)";
  log(); 
}

console.log(enemy); -> 코드상으로 접근X

wrapper();

스코프는 IIFE의 기반이됨

제로초 블로그 스코프 정리
https://www.zerocho.com/category/JavaScript/post/5740531574288ebc5f2ba97e




클로저
함수와 함수가 접근할 수 있는 스코프가 클로저 관계를 맺는다

var name = "zero";
function log() {
  console.log(name); 
}

function wrapper() {
  var name = "nero";
  log(); 
}
wrapper();

전역 범위안에 함수 log와 wrapper가 있음
전역범위랑 함수 log랑 클로저 관계


for (var i = 0; i < 100; i++) {
  setTimeout(function() {
    console.log(i); //i는 197번째의 i가 무조건 된다(렉시컬 스코프)
  }, i * 1000); //이 i는 0부터 순서대로실행됨
}

=> 많이하는 전형적인 실수(for과 setTimeout이 만나면 반복문이 안됨)
=> 1부터 99까지 순서대로 숫자가 나오는게 아니라 그냥 처음부터 100만 찍힘
=> callstack에서 i는 이미 100이 되어있고 그다음 setTimeout에 의해 1초마다 실행
=> 클로저의 특성을 사용해서 해결할 수 있음
★=> 함수안의 변수는 "실행"될때 값이 결정되기 때문에 i는 이미 100이 되어버렸으므로 function()안의 console.log(i)는 100이란 결과를 나타냄


=> 위의 반복문은 JS는 이렇게 해석함
=> console.log의 i는 숫자가 0,1,2..로 바뀌는게 아니라 그냥 i
 setTimeout(function() {
    console.log(i); 
  }, 0 * 1000);
   setTimeout(function() {
    console.log(i); 
  }, 1 * 1000);
   setTimeout(function() {
    console.log(i); 
  }, 2 * 1000);
...


해결책
for (var i = 0; i < 100; i++) {
  (function 클로저(j) {
    setTimeout(function() {
      console.log(j); //렉시컬 스코프에의해 226줄의 j하고 무조껀 연결되어있음
    }, j * 1000);
  })(i);
}
=> j가 인자를 받아서 간직하고 있음
=> 매개변수 j도 함수안의 변수로 치면 된다.
=> j랑 function이 클로저 관계


제로초 블로그 함수 컨택스트와 클로저 정리
https://www.zerocho.com/category/JavaScript/post/5741d96d094da4986bc950a0


 e.currentTarget.classList.add('opened');
태그.classList로 태그의 클래스에 접근, add나 remove로 추가 삭제

재귀함수 
- 무한반복 막아줘야됨
- 꾸준한 연습이 필요


null이나 빈칸, undefined를 제거하는 filter의 방법
주변칸.filter(v => !!v);
  주변칸
              .filter(function(v) {
                return !!v;
              })
              (재귀함수 안씀)

재귀형식으로 코딩할때는 효율성을 체크해야함


 e.currentTarget.textContent = 주변지뢰개수 || "";
 주변지뢰개수가 거짓인값이면 뒤에껄 써라

조건문같은 것에서 거짓인 값
'', 0, NaN, null, undefined, false

 if(중단플래그){
  return;
}
: return으로 함수의 실행을 중간에 끊을 수 있음

완성본을 낼시 남은 콘솔은 다 지워야함

기록을볼떄 
태그는 console.dir()가 남
일반은 console.log()